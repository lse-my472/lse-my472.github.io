---
title: "Seminar 2.1: Basic R"
subtitle: "LSE MY472: Data for Data Scientists"
date-modified: "2 October 2025" 
date-format: "D MMMM YYYY"
toc: true
format:
  html:
    embed-resources: true
    toc: true
    mathjax: true
execute:
  echo: true
  eval: true
---

This notebook provides a brief review of some R building blocks that we will rely on throughout this course. This notebook is not a complete review of R---please be sure to finish the R preparatory course, which is linked in the Moodle page for this course.

This notebook will also covers how to use good practices when setting up your notebooks for others to use.

::: {.callout-tip}
Reminder: you can adjust the global execution options in the document preamble above so that you will see your work when you compile. You can also adjust the execution options for each code chunk, which will override the global execution option that have been set in the preamble. Review Week 1's seminar materials for more information.
:::

## Set up code

It is good practice to get used to adding "set up code" to your notebooks and scripts that help other users run the code. There are two main aspects we'll briefly cover here: directory management and loading required packages.

### Directory management

Consider this hypothetical scenario: a user has downloaded this `.qmd` file to their computer. They need to be able to execute the code it in, which will include reading and writing external files (e.g., text documents, datasets, etc.).

One approach is to include a chunk very early (and prominently) in the notebook instructing the user to specify the working directory they want to use. 

```{r}
wdir <- "" # paste your working directory here 
```

In MY472, we will use this approach. However, we expect you to use a standardised directory structure for your coursework, which you set up last seminar. So, unless you have decided to rebel and use your own directory structure, then the following code should work for you. 

```{r}
wdir <- "~/LSE-MY472-AT25/Seminar02" 
```

::: {.callout-note}
The specific directories we will use in MY472 will depend on the week. For example, this week's seminar materials will go into the `Seminar02` subdirectory of `LSE-MY472-AT25`.
:::

Next, we need to check if all the required external files are available. We will not need any external files in this notebook, but we will practice on the `robots.txt` file available on the course website.

::: {.callout-note}
We'll discuss `robots.txt` files in a later week, but in the mean time, you can read more about them on the Wikipedia page [robots.txt](https://en.wikipedia.org/wiki/Robots.txt).
:::

First, create an object with the full URL to the remote file. 

```{r}
# Where is the remote file located (full URL)
rfile <- "http://lse-my472.github.io/robots.txt"
```

Extract the file name from the URL.

```{r}
library("stringr")
file.name <- str_split(rfile, "/")[[1]]   # Split on the slashes
file.name <- file.name[length(file.name)] # Pull out last element
print(file.name)                          # Check it worked
```

Create an object with the full local file path for where you want to save the file.

```{r}
lfile <- file.path(wdir, file.name) # Where will we store file locally?
print(lfile)
```

Next, check to see if you have already downloaded a file with this name, and if not, do so.

```{r}
if(!file.exists(lfile)){        # Check if you have the file yet
  download.file(rfile, lfile)   # If not, download it
}
```

### Loading required packages

Most R code we will use in this class will require loading external packages. It is good practice to write your code so that a new user can run the code even if they do not have the packages installed yet.

One way to do this is to create some code at the beginning of your notebook that checks to see if each of the required packages are installed. 

First thing you should do is indicate which packages are required for the code. 

```{r}
req.packages <- c("stringr", "readr")
```

Then, you can check if each package is installed, and if not, stop the execution of the code.

```{r}
for(i in req.packages){
  if(i %in% installed.packages()){
    next
  } else {
    stop(sprintf("Required package '%s' is not installed. Please install it before running this script.", i))
  }
}
```

Then, when you load packages, you can include code like the following

```{r}
# install.packages("stringr") # if needed
# install.packages("readr")   # if needed
library("stringr")
library("readr")
```

::: {.callout-warning}
You should **_always_** comment code that installs packages, as you should not force a user to inadvertently install packages if they do not want to.
:::

## Objects in R

The most basic functionality of R is using it as a calculator. For example, you can do simple arithmatic, and use more complex functions, such as the square root function.

```{r}
10 / 2
sqrt(100) + sqrt(9)
exp(1)
2^3
```

As we discussed last week, the true power of R comes when you work with objects. When you create an object, you assign it a name using the "assignment operator" (`<-`), putting the name of the object on the left and defining the object on the right.

```{r}
x <- 5
y <- 10
```

While it will also work to use a `=` for assignment (as in Python), R prefers the `<-` instead of `=` to emphasise that assigning names to objects in R is not conceptually the same as an equal sign in standard mathematics. You are assigning a name, not asserting a mathematical equality!

Once you create an object, you can also print it in the console.

```{r}
print(x)
```

Note that `print()` here is a function: it takes an argument (in this case, the object `x`) and returns a value (in this case the number `5`). This is equivalent to just typing the name of the object in the console and pressing return. You will notice that some code chunks _explicitly_ ask R to print an object (as above), while others do this _implicitly_ (as below). 

```{r}
x
```

What's going on behind the scenes is that R is calling the default function to print this object; which in this case is just `print()`.

After creating objects, they are now in the "working environment" of the current R session (i.e., they are in memory). You can see them using the `ls()` function (just like the command line!).

```{r}
print(ls())
```

In Positron, you can also see them in the VARIABLES panel under SESSION on the top right. This is one convenience of using an IDE---you can often see all your variables neatly listed in a visual panel.

You can also use the `{plyr}` package to look at each object's address in memory.

```{r}
print(pryr::address(x))
```

All objects in R are immutable meaning they cannot be changed once they are created. Instead, R uses a "copy-on-modify" logic. This means that if you modify any object, a copy of the object is made (with the modifications), in a new location in memory.

```{r}
x <- x+0
print(pryr::address(x))
```

Notice that the object `x` is still 5, but it has a new location in memory since it was technically modified (although in a trivial way).

Similarly, an object in R's memory can have multiple names. When an object gets additional names, these new names are called aliases.

```{r}
x1 <- x
print(pryr::address(x1))
```

Now, the object we made above (the number 5) has two names, `x` and `x1`. Keep in mind that you can make another, completely separate object with a different name and a different location in memory that is _also_ the number 5. 

```{r}
z <- 5
print(pryr::address(z))
```

In R, you often need to use logical operators to compare objects. 

```{r}
2 == 2
c(1, 2, 3) == 2
```

The logical operator `==` used above outputs `TRUE` or `FALSE`. Other logical operators are:

```{r}
1 != 2 # not equal to
2 < 2 # less than
2 <= 2 # less than or equal to
2 > 2 # greater than
2 >= 2 # greater than or equal to
(2 < 2) | (2 <= 2) # or
(2 < 2) & (2 <= 2) # and
```

Of course, you can also compare objects by using their names instead.

```{r}
x == y
```

In this case, you are not literally comparing if the named objects are the same object in memory (i.e., with the same address), but rather, you are comparing whether the objects themselves are the same quantities. For example, note that `x` and `x1` point to the same object in memory while `x` and `z` do not, and yet, both of these comparisons yield `TRUE`:

```{r}
x == x1
x == z
```

## Data types

R has many data types, but the most common ones we'll use are:

1. numeric: `1.1`, `3`, `317`, `Inf`...
2. logical: `TRUE` or `FALSE`
3. character: `this is a character`, `hello world!`...
4. factor: `Democrat`, `Republican`, `Socialist`, ...

A convenient feature of logical values (`TRUE` and `FALSE`) is that they correspond to the integers `1` and `0` in R. This will come in handy if you want to count the number of `TRUE` values in a vector, or do other mathematical operations on a logical vector.

```{r}
x <- c(TRUE, TRUE, FALSE)
sum(x) # count the TRUE values
x * 2  # do a simple mathematical operation
```

There are a few special values: `NA`, which denotes a missing value, and `NaN`, which means Not a number. The values `Inf` and `-Inf` are considered numeric. `NULL` denotes a value that is undefined.

```{r}
0 / 0 # NaN
1 / 0 # Inf
x <- c(1, NA, 0)
x
```

You can find out the data type for each object in `R` using the function `class()`, as follows.

```{r}
class("hello world!")       # Tells you the data type
class(42)                   # Tells you the data type
class(c(1, NA, 0))          # Tells you the data type
```

You can also test an object's data type using an `is.` function, as follows.

```{r}
is.numeric("hello world!")  # Tests for the data type
is.character("hello world") # Tests for the data type
is.numeric(c(1, NA, 0))     # Tests for the data type
```

Probably one of the most useful functions in R is `str()`. It displays the internal structure of an object.

```{r}
str(x)
str(as.factor(c("Blue", "Blue", "Red")))
```

### Data structures

Building off of the data types we've learned, *data structures* combine multiple values into a single object. Some common data structures in `R` include:

1. vectors: sequence of values of a certain type
2. data frame: a table of vectors, all of the same length
3. list: collection of objects of different types

#### Vectors

We've already seen vectors created by combining multiple values with the `c()` function. An easy way to remember is that "c" is for "combining".

```{r}
student_names <- c("Bill", "Jane", "Sarah", "Fred", "Paul")
math_scores <- c(80, 75, 91, 67, 56)
verbal_scores <- c(72, 90, 99, 60, 68)
```

There are shortcuts for creating vectors with certain structures, for instance:

```{r}
nums1 <- 1:100
# -10, -5, 0, ..., 100
nums2 <- seq(-10, 100, by = 5)
# 467 equally spaced numbers between -10 and 100
nums3 <- seq(-10, 100, length.out = 467)
```

Notice that we used `seq()` to generate both `nums2` and `nums3`. The different behavior is controlled by which arguments (e.g. `by`, `length.out`) are supplied to the function `seq()`.

With vectors we can carry out some of the most fundamental tasks in data analysis, such as descriptive statistics

```{r}
mean(math_scores)
min(math_scores - verbal_scores)
summary(verbal_scores)
```

and plots.

```{r}
plot(x = math_scores, y = verbal_scores)
text(x = math_scores, y = verbal_scores, labels = student_names)
```

It's easy to pull out specific entries in a vector using `[]`. For example,

```{r}
math_scores[3]
math_scores[1:3]
math_scores[-c(4:5)]
math_scores[which(verbal_scores >= 90)]
math_scores[3] <- 92
math_scores
```

#### Data frames

Data frames allow us to combine many vectors of the same length into a single object.

```{r}
students <- data.frame(student_names, math_scores, verbal_scores)
students
summary(students)
```

Notice that `student_names` is a different class (character) than `math_scores` (numeric), yet a data frame combines their values into a single object. We can also create data frames that include new variables:

```{r}
students$final_scores <- 0
students$final_scores <- (students$math_scores + students$verbal_scores) / 2
students
```

```{r}
age <- c(18, 19, 20, 21, 22)
students2 <- data.frame(student_names, age)
students2
```

And merge them with other dataframes (here based on the students_name column)

```{r}
# merge different data frames
students3 <- merge(students, students2)
students3
```

In a later week, you will learn how to manipulate tabular data using tools available in the tidyverse, which stores tabular data as `tibble` objects and has useful tools for merging and manipulating data.

#### Lists

Lists are an even more flexible way of combining multiple objects into a single object. As you will see throughout the course, we will use lists to store the output of our scraping steps. Using lists, we can combine together vectors of different lengths:

```{r}
list1 <- list(some_numbers = 1:10, some_letters = c("a", "b", "c"))
list1
```

or even vectors and data frames, or multiple data frames:

```{r}
schools <- list(school_name = "LSE", students = students,
                    faculty = data.frame(name = c("Kelly Jones", "Matt Smith"),
                                         age = c(41, 55)))
schools
```

You can access a list component in several different ways:

```{r}
schools[[1]]
schools[["faculty"]]
schools$students
schools[["students"]]
```